using LinearAlgebra
using DifferentialEquations
using LSODA

"""
    createorbits(intersectionpoints::vector of vector of 3-vectors,B::3-vector,gradE::function,mult_factor::Num,endtime::Num,num_integratedpoints::Int64,abstol::Num,reltol::Num,abstol_termination::Num)

    returns: orbits(vector of vector of vector of 3-vectors, with each vector of 3-vectors corresponding to  ONE orbit in a plane)
    i.e. orbits[i][j] is a vector of points lying along one orbit
         orbits[i] is a vector of vectors, with each vector containing curves lying on a single plane
"""
function createorbits!(intersectionpoints,B,gradE,mult_factor,endtime,num_integratedpoints,abstol,reltol,abstol_termination)
    orbits = []
    B_normalized = B/norm(B)

    for intersectionpoints_in_plane in intersectionpoints
        orbits_in_plane = []

        while length(intersectionpoints_in_plane) > 0 #keep creating orbits until all orbits have been solved for
            point = pop!(intersectionpoints_in_plane)

            function rhs!(dk,k,p,t) #dk/dk, defined in a way to mutate input dk (supposed to be faster)
                dk .= cross(gradE(k),B_normalized*mult_factor) #dk/dt = v x B
            end

            k0 = point #initial condition
            timespan = (0,endtime) #endtime is the time at which integration terminates if orbit did not close yet
            prob = ODEProblem(rhs!,k0,timespan)

            #implement termination condition upon orbit completion
            #orbit "closes" when current point is within abstol_termination distance of starting point
            condition(u,t,integrator) = (norm(u - k0) < abstol_termination) && (dot(u-k0,cross(gradE(u),B_normalized))<0) #second condition is to make sure condition only triggers on orbit closing
            affect!(integrator) = terminate!(integrator)
            cb = DiscreteCallback(condition, affect!)

            #num_integratedpoints is the maximum number of points that will be integrated if orbits don't close
            #abstol and reltol are the absolute and relative tolerances of the integrator
            sol = solve(prob,callback=cb,saveat=timespan[end]/num_integratedpoints,abstol=abstol,reltol=reltol,alg=AutoVern7(Rodas5()))   #solve for the orbit
            push!(orbits_in_plane,sol.u)
            if sol.t[end] == timespan[end] error("Some orbits did not terminate! Increase termination tolerance or decrease integration tolerance") end

            indices_to_be_deleted = [] #this deletes points from intersectionpoints_in_plane if they lie on the current orbit
            for (index,initialpoint) in enumerate(intersectionpoints_in_plane)
                if liesOnOrbit(initialpoint,sol.u,abstol_termination)
                    push!(indices_to_be_deleted,index)
                end
            end
            deleteat!(intersectionpoints_in_plane,indices_to_be_deleted)
        end

        push!(orbits,orbits_in_plane)
    end
    return orbits
end

"""
    liesOnOrbit(point::3-vector,orbit::list of 3-vectors,tolerance::Num)

returns true if point lies on orbit
"""
function liesOnOrbit(point,orbit,tolerance)
    for point_on_orbit in orbit
        if norm(point_on_orbit-point)<tolerance 
            return true 
        end
    end
    return false
end


"""
    orbitCleanUp(orbits::vector of vector of vector 3-vectors,spacing::Float64) 

takes in orbits generated by createorbits and 
1. for every 1-D curve in orbits, replaces it with a 1-D curve with equal spacing

all this is performed making sure orbits[i] only contains orbits lying in a single plane
"""
function orbitCleanUp(orbits,spacing)
    new_orbits = Vector{Vector{Vector{Float64}}}[]

    for orbits_in_plane in orbits
        new_orbits_in_plane = Vector{Vector{Float64}}[]
        for orbit in orbits_in_plane

            new_orbit = [orbit[1]]
            prev_point = orbit[1]

            for point in orbit
                if norm(point-prev_point) > spacing
                    push!(new_orbit,point)
                    prev_point=point
                end
            end

            if length(new_orbit)>2 push!(new_orbits_in_plane,new_orbit) end
        end

        push!(new_orbits,new_orbits_in_plane)
    end

    return new_orbits
end


